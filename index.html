<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>车棋游戏</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
            box-sizing: border-box;
        }
        @media (min-width: 768px) {
            body {
                max-width: 800px;
                padding: 20px;
            }
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 0;
            margin: 10px auto;
            position: relative;
            background-color: #d8c1a0;
            border: 2px solid #8B4513;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            padding: 0;
            border-radius: 4px;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 8/9;
        }
        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #f5e9c9;
            cursor: pointer;
            box-sizing: border-box;
            border: 1px solid #c3a978;
            transition: background-color 0.2s;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
        }
        .cell:hover {
            background-color: #f7ebd3;
        }
        .cell.selected {
            background-color: #ffce9e;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        .cell.move-suggestion {
            background-color: #c6ecc6 !important;
            box-shadow: inset 0 0 5px rgba(0,128,0,0.2);
        }
        .cell::before {
            content: attr(data-coord);
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: min(8px, 0.5em);
            color: #666;
        }
        .piece {
            width: 80%;
            height: 80%;
            max-width: 40px;
            max-height: 40px;
            border-radius: 50%;
            background-color: #ffffff;
            border: 2px solid #000;
            font-size: clamp(16px, 5vw, 24px);
            user-select: none;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 3px rgba(0,0,0,0.3);
            transition: transform 0.1s;
            touch-action: none;
        }
        .piece:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        .car {
            color: red;
            background-color: #ffdddd;
            border-color: red;
        }
        .pawn, .rook, .knight, .cannon, .bishop, .advisor, .king {
            color: black;
            background-color: #ddffdd;
            border-color: black;
        }
        .input-area, .result-area, .archive-area {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            width: 100%;
            box-sizing: border-box;
        }
        .result-area {
            min-height: 50px;
        }
        .btn {
            padding: 10px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 0;
            width: 100%;
            touch-action: manipulation;
        }
        .btn:hover {
            background-color: #45a049;
        }
        .btn-danger {
            background-color: #dc3545;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }
        .btn-action {
            margin-right: 5px;
            margin-bottom: 5px;
        }
        .move-suggestion {
            background-color: #c6ecc6 !important;
        }
        .input-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        @media (min-width: 576px) {
            .input-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        .move-car-area {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f0f7ff;
        }
        .dragging {
            opacity: 0.6;
        }
        .valid-drop {
            background-color: rgba(0, 255, 0, 0.2);
        }
        .invalid-drop {
            background-color: rgba(255, 0, 0, 0.2);
        }
        .game-status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border-left: 4px solid #4CAF50;
        }
        .captured {
            animation: capture-animation 0.5s;
        }
        @keyframes capture-animation {
            0% { background-color: #f5e9c9; }
            50% { background-color: #ff6b6b; }
            100% { background-color: #f5e9c9; }
        }
        .delete-mode {
            background-color: #ffe6e6;
        }
        .delete-mode .cell:hover {
            background-color: #ffcccc;
            cursor: not-allowed;
        }
        .delete-mode .piece:hover {
            background-color: #ff9999;
            cursor: not-allowed;
        }
        .archive-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
        }
        .archive-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }
        .archive-item:hover {
            background-color: #f0f0f0;
        }
        .archive-item:last-child {
            border-bottom: none;
        }
        .archive-name {
            flex: 1;
            margin-right: 10px;
        }
        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
        }
        .end-page-text {
            font-size: 12px;
            color: red;
        }
        input[type="number"], input[type="text"], select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px; /* 防止iOS上缩放 */
        }
        /* 移动端触摸优化 */
        .mobile-controls {
            display: none;
            margin-top: 15px;
            text-align: center;
        }
        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }
        }
        .mobile-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        
        /* 适配小屏幕的按钮组 */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .collapsible-section {
            margin-bottom: 15px;
        }
        .collapsible-section summary {
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .collapsible-section[open] summary {
            margin-bottom: 10px;
        }
				.pay-img{
					display: flex;
					justify-content: space-around;
				}
				.pay-img img {
					width: 200px;
					height: 200px;
				}
    </style>
</head>
<body>
    <h1>车棋游戏</h1>
    <p>规则: 您操控一个车(红色)，对方有多种象棋棋子。车可以横竖直线移动，需要避开对方棋子的攻击范围。每回合击杀一个棋子，游戏继续。</p>
    
    <div class="game-status" id="gameStatus">游戏状态：拖拽棋子可以移动它们。移动后系统会自动计算车的最佳移动位置。</div>
    
    <div class="board" id="board"></div>
    
    <div class="mobile-controls" id="mobileControls">
        <p class="mobile-info">提示：在移动设备上，先点击棋子选中，再点击目标位置移动</p>
    </div>
    
    <details class="collapsible-section" open>
        <summary>添加棋子</summary>
        <div class="input-area">
            <div class="input-grid">
                <div>
                    <label for="pieceType">棋子类型:</label>
                    <select id="pieceType">
                        <option value="pawn">卒</option>
                        <option value="rook">车</option>
                        <option value="knight">马</option>
                        <option value="cannon">炮</option>
                        <option value="bishop">象</option>
                        <option value="advisor">士</option>
                        <option value="king">将</option>
                    </select>
                </div>
                <div>
                    <label for="xCoord">X坐标 (1-8):</label>
                    <input type="number" id="xCoord" min="1" max="8" value="1">
                </div>
                <div>
                    <label for="yCoord">Y坐标 (1-9):</label>
                    <input type="number" id="yCoord" min="1" max="9" value="1">
                </div>
                <div class="button-group">
                    <button class="btn btn-action" id="addPiece">添加棋子</button>
                    <button class="btn btn-danger btn-action" id="toggleDeleteMode">删除棋子</button>
                </div>
            </div>
        </div>
    </details>
    
    <div class="result-area" id="resultArea">
        <h3>车的最佳移动</h3>
        <p>当前无建议。请添加棋子后计算。</p>
    </div>
    
    <div class="button-group">
        <button class="btn" id="calculateMove">计算最佳移动</button>
        <button class="btn" id="resetBoard">重置棋盘</button>
    </div>
    
    <details class="collapsible-section" open>
        <summary>棋局存档</summary>
        <div class="archive-area">
            <div class="input-grid">
                <div>
                    <label for="archiveName">存档名称:</label>
                    <input type="text" id="archiveName" placeholder="输入存档名称">
                </div>
                <div class="button-group">
                    <button class="btn btn-action" id="saveGame">保存当前棋局</button>
                    <button class="btn btn-action" id="loadGameList">查看存档列表</button>
                </div>
            </div>
            <div class="archive-list" id="archiveList" style="display: none;">
                <p>加载中...</p>
            </div>
        </div>
    </details>
		<h3>打赏</h3>
		<div>
			<p>如果你觉得这个对你有帮助，你可以帮作者买一杯咖啡表示支持，创作不易，谢谢老板！❤❤❤</p>
			<p>If you think this project is helpful to you, you can help the author buy a cup of coffee to show your support!</p>
			<div class="pay-img">
				<img src="./wechat.jpg"/>
				<img src="./alipay.jpg"/>
			</div>
		</div>
    
    <p class="end-page-text">著作权归 街角音20区-角色ID-400004000048417 所有，侵权必究!!!</p>
    <script>
        // 初始化棋盘和棋子
        const board = document.getElementById('board');
        const resultArea = document.getElementById('resultArea');
        const gameStatus = document.getElementById('gameStatus');
        let pieces = [];
        let carPosition = { x: 4, y: 7 }; // 车的初始位置
        let draggedPiece = null;
        let draggedPieceElement = null;
        let originalPosition = null;
        let isDeleteMode = false; // 是否处于删除模式
        let selectedPiece = null; // 移动端：当前选中的棋子
        let isMobileDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        // 初始化棋盘
        function initBoard() {
            board.innerHTML = '';
            
            // 创建单元格和坐标点
            for (let y = 1; y <= 9; y++) {
                for (let x = 1; x <= 8; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.dataset.coord = `(${x},${y})`;
                    
                    // 添加拖拽相关事件处理
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('drop', handleDrop);
                    cell.addEventListener('dragenter', handleDragEnter);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('click', () => selectCell(x, y));
                    
                    board.appendChild(cell);
                }
            }
            
            // 初始化棋子
            pieces = [
                { type: 'pawn', x: 4, y: 3 },
                { type: 'pawn', x: 6, y: 3 },
                { type: 'pawn', x: 8, y: 3 }
            ];
            
            // 添加车
            pieces.push({ type: 'car', x: carPosition.x, y: carPosition.y });
            
            renderPieces();
            
            // 初始状态下计算最佳移动
            setTimeout(calculateBestMoveForCar, 500);
            
            // 为移动端添加触摸事件处理
            if (isMobileDevice) {
                setupMobileTouchHandlers();
            }
        }
        
        // 渲染棋子 - 修改为支持移动端
        function renderPieces() {
            // 清除所有棋子
            document.querySelectorAll('.piece').forEach(p => p.remove());
            document.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('selected');
                c.classList.remove('move-suggestion');
                c.classList.remove('valid-drop');
                c.classList.remove('invalid-drop');
            });
            
            // 添加棋子 - 放回格子内
            pieces.forEach(piece => {
                const cell = findCell(piece.x, piece.y);
                if (!cell) return;
                
                const pieceElem = document.createElement('div');
                pieceElem.className = `piece ${piece.type}`;
                pieceElem.textContent = getPieceSymbol(piece.type);
                
                if (!isMobileDevice) {
                    // 桌面端：设置拖拽属性
                    pieceElem.draggable = true;
                    pieceElem.addEventListener('dragstart', (e) => handleDragStart(e, piece));
                    pieceElem.addEventListener('dragend', handleDragEnd);
                } else {
                    // 移动端：设置点击事件
                    pieceElem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleMobilePieceClick(piece);
                    });
                }
                
                // 添加删除功能 - 点击删除棋子
                pieceElem.addEventListener('click', (e) => {
                    if (isDeleteMode && piece.type !== 'car') { // 不允许删除车
                        deletePiece(piece);
                        e.stopPropagation(); // 防止触发单元格的点击事件
                    }
                });
                
                cell.appendChild(pieceElem);
            });
            
            // 高亮车的位置
            const carCell = findCell(carPosition.x, carPosition.y);
            if (carCell) {
                carCell.classList.add('selected');
            }
            
            // 如果在删除模式，添加删除模式类
            if (isDeleteMode) {
                board.classList.add('delete-mode');
            } else {
                board.classList.remove('delete-mode');
            }
            
            // 显示当前选中的棋子（移动端）
            if (selectedPiece) {
                const selectedCell = findCell(selectedPiece.x, selectedPiece.y);
                if (selectedCell) {
                    selectedCell.classList.add('selected');
                    
                    // 显示可能的移动位置（如果是车）
                    if (selectedPiece.type === 'car') {
                        showPossibleMoves();
                    }
                }
            }
        }
        
        // 删除棋子函数
        function deletePiece(piece) {
            if (piece.type === 'car') {
                alert('不能删除车！');
                return;
            }
            
            // 从数组中移除棋子
            pieces = pieces.filter(p => p !== piece);
            
            // 更新状态
            gameStatus.textContent = `删除了 ${getPieceSymbol(piece.type)} 在坐标 (${piece.x}, ${piece.y})`;
            
            // 重新渲染棋盘
            renderPieces();
            
            // 重新计算最佳移动
            setTimeout(calculateBestMoveForCar, 500);
        }
        
        // 切换删除模式
        function toggleDeleteMode() {
            isDeleteMode = !isDeleteMode;
            
            const deleteBtn = document.getElementById('toggleDeleteMode');
            if (isDeleteMode) {
                deleteBtn.textContent = '退出删除模式';
                gameStatus.textContent = '删除模式：点击棋子可以删除它（车不能删除）';
            } else {
                deleteBtn.textContent = '删除棋子';
                gameStatus.textContent = '已退出删除模式';
            }
            
            renderPieces();
        }
        
        // 拖拽开始
        function handleDragStart(e, piece) {
            // 如果处于删除模式，不允许拖拽
            if (isDeleteMode) {
                e.preventDefault();
                return;
            }
            
            draggedPiece = piece;
            draggedPieceElement = e.target;
            originalPosition = { x: piece.x, y: piece.y };
            
            // 设置拖拽效果
            e.target.classList.add('dragging');
            
            // 显示可能的移动位置
            if (piece.type === 'car') {
                showPossibleMoves();
            }
            
            // 延迟设置，确保能看到拖拽的元素
            setTimeout(() => {
                e.target.style.opacity = '0.4';
            }, 0);
        }
        
        // 拖拽经过
        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault(); // 允许放置
            }
            return false;
        }
        
        // 拖拽进入
        function handleDragEnter(e) {
            // 获取目标单元格坐标
            const targetX = parseInt(this.dataset.x);
            const targetY = parseInt(this.dataset.y);
            
            // 拖拽布局模式：所有棋子都能放在任意位置，只要该位置没有其他棋子
            if (draggedPiece) {
                if (!pieces.some(p => p !== draggedPiece && p.x === targetX && p.y === targetY)) {
                    this.classList.add('valid-drop');
                } else {
                    this.classList.add('invalid-drop');
                }
            }
        }
        
        // 拖拽离开
        function handleDragLeave(e) {
            this.classList.remove('valid-drop');
            this.classList.remove('invalid-drop');
        }
        
        // 拖拽结束
        function handleDragEnd(e) {
            // 恢复样式
            e.target.classList.remove('dragging');
            e.target.style.opacity = '1';
            
            // 清除高亮
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('valid-drop');
                cell.classList.remove('invalid-drop');
            });
            
            draggedPiece = null;
            draggedPieceElement = null;
        }
        
        // 拖拽放置
        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedPiece) return;
            
            // 获取目标单元格坐标
            const targetX = parseInt(this.dataset.x);
            const targetY = parseInt(this.dataset.y);
            
            // 检查目标位置是否已有棋子（除了被拖拽的棋子自身）
            const targetPiece = pieces.find(p => p !== draggedPiece && p.x === targetX && p.y === targetY);
            
            // 如果是车并且目标位置有其他棋子，则吃掉它
            if (draggedPiece.type === 'car' && targetPiece) {
                pieces = pieces.filter(p => p !== targetPiece);
                gameStatus.textContent = `吃掉了 ${getPieceSymbol(targetPiece.type)} 在坐标 (${targetX}, ${targetY})`;
                // 播放吃子动画
                this.classList.add('captured');
                setTimeout(() => this.classList.remove('captured'), 500);
            } else if (targetPiece) {
                // 其他棋子不能移动到有棋子的位置
                return false;
            }
            
            // 更新棋子位置
            draggedPiece.x = targetX;
            draggedPiece.y = targetY;
            
            // 如果是车，更新车的位置
            if (draggedPiece.type === 'car') {
                carPosition = { x: targetX, y: targetY };
            }
            
            renderPieces();
            
            // 棋盘状态改变，重新计算最佳移动
            setTimeout(calculateBestMoveForCar, 500);
            
            return false;
        }
        
        // 检查车的移动是否有效
        function isValidCarMove(fromX, fromY, toX, toY) {
            // 检查是否是直线移动
            if (fromX !== toX && fromY !== toY) {
                return false;
            }
            
            // 检查路径上是否有其他棋子
            if (isPathBlocked(fromX, fromY, toX, toY)) {
                return false;
            }
            
            return true;
        }
        
        // 获取棋子符号
        function getPieceSymbol(type) {
            switch(type) {
                case 'car': return '车';
                case 'pawn': return '卒';
                case 'rook': return '车';
                case 'knight': return '马';
                case 'cannon': return '炮';
                case 'bishop': return '象';
                case 'advisor': return '士';
                case 'king': return '将';
                default: return '?';
            }
        }
        
        // 查找指定坐标的单元格
        function findCell(x, y) {
            return document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
        }
        
        // 选择单元格 - 支持移动端
        function selectCell(x, y) {
            // 如果处于删除模式，点击空格子不做任何操作
            if (isDeleteMode) {
                return;
            }
            
            const piece = pieces.find(p => p.x === x && p.y === y);
            
            if (isMobileDevice) {
                // 移动端逻辑
                if (piece) {
                    // 如果已经有选中的棋子，并且它是车，则尝试吃子
                    if (selectedPiece && selectedPiece.type === 'car') {
                        // 检查车是否可以移动到该位置吃子
                        if (isValidCarMove(selectedPiece.x, selectedPiece.y, x, y)) {
                            // 吃掉棋子
                            pieces = pieces.filter(p => p !== piece);
                            gameStatus.textContent = `吃掉了 ${getPieceSymbol(piece.type)} 在坐标 (${x}, ${y})`;
                            
                            // 播放吃子动画
                            const cell = findCell(x, y);
                            if (cell) {
                                cell.classList.add('captured');
                                setTimeout(() => cell.classList.remove('captured'), 500);
                            }
                            
                            // 移动车
                            selectedPiece.x = x;
                            selectedPiece.y = y;
                            carPosition = { x, y };
                            
                            // 检查游戏状态
                            if (isCarInDanger()) {
                                gameStatus.textContent = '车进入了敌方棋子的攻击范围，游戏结束！';
                                setTimeout(() => {
                                    alert('车进入了敌方棋子的攻击范围，游戏结束！');
                                    initBoard();
                                }, 100);
                                selectedPiece = null;
                                renderPieces();
                                return;
                            }
                            
                            // 移动成功提示
                            gameStatus.textContent = `车吃掉了 ${getPieceSymbol(piece.type)} 移动到 (${x}, ${y})`;
                            
                            // 移动完成，清除选择
                            selectedPiece = null;
                            renderPieces();
                            
                            // 重新计算最佳移动
                            setTimeout(calculateBestMoveForCar, 500);
                            return;
                        } else {
                            gameStatus.textContent = "无法吃掉该棋子！车只能直线移动且不能越过其他棋子";
                            return;
                        }
                    } 
                    else {
                        // 如果没有选中棋子，或选中的不是车，则选择点击的棋子
                        handleMobilePieceClick(piece);
                    }
                } else if (selectedPiece) {
                    // ...existing code for moving to empty cell...
                }
            } else {
                // 桌面端原有逻辑
                if (piece && piece.type === 'car') {
                    // 如果点击的是车，显示可能的移动位置
                    showPossibleMoves();
                } else if (piece) {
                    // 如果点击的是其他棋子
                    gameStatus.textContent = `选中的棋子: ${getPieceSymbol(piece.type)} 在坐标 (${x}, ${y})，拖拽可以移动它`;
                } else {
                    // 如果是空单元格，尝试移动车
                    const car = pieces.find(p => p.type === 'car');
                    if (car) {
                        // 检查是否有棋子在目标位置
                        const targetPiece = pieces.find(p => p.x === x && p.y === y);
                        if (targetPiece) {
                            // 如果有棋子，则吃掉它
                            pieces = pieces.filter(p => p !== targetPiece);
                            gameStatus.textContent = `吃掉了 ${getPieceSymbol(targetPiece.type)} 在坐标 (${x}, ${y})`;
                            
                            // 播放吃子动画
                            const cell = findCell(x, y);
                            if (cell) {
                                cell.classList.add('captured');
                                setTimeout(() => cell.classList.remove('captured'), 500);
                            }
                        }
                        
                        moveCarTo(x, y);
                        
                        // 自动计算下一步最佳移动
                        setTimeout(calculateBestMoveForCar, 500);
                    }
                }
            }
        }
        
        // 显示车可能的移动位置
        function showPossibleMoves() {
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('move-suggestion'));
            
            // 获取安全的移动位置
            const safeMoves = getSafeMovesForCar();
            
            // 高亮显示安全的移动位置
            safeMoves.forEach(move => {
                const cell = findCell(move.x, move.y);
                if (cell) {
                    cell.classList.add('move-suggestion');
                }
            });
        }
        
        // 移动车到指定位置
        function moveCarTo(x, y) {
            // 检查是否存在车
            const carPiece = pieces.find(p => p.type === 'car');
            if (!carPiece) return;
            
            // 检查目标位置是否有棋子
            const targetPiece = pieces.find(p => p.x === x && p.y === y);
            if (targetPiece) {
                // 如果是敌方棋子，吃掉它（从棋盘上移除）
                if (targetPiece.type !== 'car') {
                    pieces = pieces.filter(p => p !== targetPiece);
                    gameStatus.textContent = `吃掉了 ${getPieceSymbol(targetPiece.type)} 在坐标 (${x}, ${y})`;
                    // 播放一个简单的吃子动画效果
                    const targetCell = findCell(targetPiece.x, targetPiece.y);
                    if (targetCell) {
                        targetCell.classList.add('captured');
                        setTimeout(() => targetCell.classList.remove('captured'), 500);
                    }
                }
            }
            
            // 移动车
            carPiece.x = x;
            carPiece.y = y;
            carPosition = { x, y };
            
            // 检查游戏状态
            if (isCarInDanger()) {
                gameStatus.textContent = '车进入了敌方棋子的攻击范围，游戏结束！';
                setTimeout(() => {
                    alert('车进入了敌方棋子的攻击范围，游戏结束！');
                    initBoard();
                }, 100);
                return;
            }
            
            renderPieces();
        }
        
        // 检查车是否在危险中
        function isCarInDanger() {
            const car = pieces.find(p => p.type === 'car');
            if (!car) return false;
            
            return pieces.some(piece => {
                if (piece.type === 'car') return false;
                
                return canPieceAttack(piece, car.x, car.y);
            });
        }
        
        // 检查路径是否被阻挡
        function isPathBlocked(fromX, fromY, toX, toY) {
            // 水平移动
            if (fromY === toY) {
                const minX = Math.min(fromX, toX);
                const maxX = Math.max(fromX, toX);
                
                for (let x = minX + 1; x < maxX; x++) {
                    if (pieces.some(p => p.x === x && p.y === fromY)) {
                        return true;
                    }
                }
            }
            
            // 垂直移动
            if (fromX === toX) {
                const minY = Math.min(fromY, toY);
                const maxY = Math.max(fromY, toY);
                
                for (let y = minY + 1; y < maxY; y++) {
                    if (pieces.some(p => p.x === fromX && p.y === y)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 获取车的安全移动位置 - 恢复为按照象棋规则计算
        function getSafeMovesForCar() {
            const car = pieces.find(p => p.type === 'car');
            if (!car) return [];
            
            const possibleMoves = [];
            
            // 横向移动
            for (let x = 1; x <= 8; x++) {
                if (x !== car.x && !isPathBlocked(car.x, car.y, x, car.y)) {
                    possibleMoves.push({ x, y: car.y });
                }
            }
            
            // 纵向移动
            for (let y = 1; y <= 9; y++) {
                if (y !== car.y && !isPathBlocked(car.x, car.y, car.x, y)) {
                    possibleMoves.push({ x: car.x, y });
                }
            }
            
            // 过滤出安全的移动
            return possibleMoves.filter(move => {
                // 检查移动到该位置是否安全
                return !pieces.some(piece => {
                    // 忽略车自己
                    if (piece.type === 'car') return false;
                    
                    // 如果这个位置已经有棋子，检查是否可以吃掉它
                    if (piece.x === move.x && piece.y === move.y) {
                        return false; // 可以吃掉这个棋子，所以仍然是安全的
                    }
                    
                    // 检查移动后是否会被其他棋子攻击
                    return canPieceAttack(piece, move.x, move.y);
                });
            });
        }
        
        // 检查棋子是否可以攻击指定坐标
        function canPieceAttack(piece, x, y) {
            switch(piece.type) {
                case 'pawn': // 卒
                    // 卒可以左右或上下走一步
                    return Math.abs(piece.x - x) + Math.abs(piece.y - y) === 1;
                
                case 'rook': // 车
                    // 车可以横竖直线走任意步数，但不能跳过其他棋子
                    if ((piece.x === x || piece.y === y) && !isPathBlocked(piece.x, piece.y, x, y)) {
                        return true;
                    }
                    return false;
                
                case 'knight': // 马
                    // 马走日，但不能蹩马腿
                    if ((Math.abs(piece.x - x) === 1 && Math.abs(piece.y - y) === 2) || 
                        (Math.abs(piece.x - x) === 2 && Math.abs(piece.y - y) === 1)) {
                        // 检查马腿
                        const legX = piece.x + Math.sign(x - piece.x) * (Math.abs(piece.x - x) === 2 ? 1 : 0);
                        const legY = piece.y + Math.sign(y - piece.y) * (Math.abs(piece.y - y) === 2 ? 1 : 0);
                        
                        if (pieces.some(p => p.x === legX && p.y === legY)) {
                            return false; // 马腿被阻挡
                        }
                        return true;
                    }
                    return false;
                
                case 'cannon': // 炮
                    // 炮走法与车相似，但吃子时需要一个炮架
                    if (piece.x === x || piece.y === y) {
                        // 检查路径上的棋子数
                        let pieceCount = 0;
                        
                        if (piece.x === x) {
                            const minY = Math.min(piece.y, y);
                            const maxY = Math.max(piece.y, y);
                            
                            for (let i = minY + 1; i < maxY; i++) {
                                if (pieces.some(p => p.x === x && p.y === i)) {
                                    pieceCount++;
                                }
                            }
                        } else {
                            const minX = Math.min(piece.x, x);
                            const maxX = Math.max(piece.x, x);
                            
                            for (let i = minX + 1; i < maxX; i++) {
                                if (pieces.some(p => p.x === i && p.y === y)) {
                                    pieceCount++;
                                }
                            }
                        }
                        
                        // 如果目标位置是空的，需要没有棋子在路径上
                        const targetPiece = pieces.find(p => p.x === x && p.y === y);
                        if (!targetPiece) {
                            return pieceCount === 0;
                        } else {
                            // 如果目标位置有棋子，需要有且只有一个炮架
                            return pieceCount === 1;
                        }
                    }
                    return false;
                
                case 'bishop': // 象
                    // 象走田，且不能过河
                    if (Math.abs(piece.x - x) === 2 && Math.abs(piece.y - y) === 2) {
                        // 检查象心
                        const heartX = (piece.x + x) / 2;
                        const heartY = (piece.y + y) / 2;
                        
                        if (pieces.some(p => p.x === heartX && p.y === heartY)) {
                            return false; // 象心被阻挡
                        }
                        return true;
                    }
                    return false;
                
                case 'advisor': // 士
                    // 士走斜线一格
                    return Math.abs(piece.x - x) === 1 && Math.abs(piece.y - y) === 1;
                
                case 'king': // 将
                    // 将走一格（横竖）
                    return (Math.abs(piece.x - x) === 1 && piece.y === y) || 
                           (Math.abs(piece.y - y) === 1 && piece.x === x);
                
                default:
                    return false;
            }
        }
        
        // 计算车的最佳移动 - 更新策略，应对动态棋局
        function calculateBestMoveForCar() {
            // 按照象棋规则获取车的安全移动位置
            const safeMoves = getSafeMovesForCar();
            
            if (safeMoves.length === 0) {
                resultArea.innerHTML = '<h3>车的最佳移动</h3><p>没有安全的移动位置！游戏结束。</p>';
                gameStatus.textContent = '没有安全的移动位置！游戏结束。';
                return;
            }
            
            // 将移动评分与决策过程进行彻底改进
            // 1. 先评估每个可能的移动
            const evaluatedMoves = safeMoves.map(move => {
                // 创建移动评估对象
                const evaluation = {
                    move: move,
                    // 记录此位置是否可以立即吃子
                    canCaptureNow: false,
                    // 存储可能被吃掉的棋子
                    targetPiece: null,
                    // 评分初始化为0
                    score: 0,
                    // 吃子路径
                    capturePath: [],
                    // 立即吃子的价值（不同棋子有不同价值）
                    immediateValue: 0,
                    // 未来位置价值
                    positionValue: 0,
                    // 逃脱威胁价值
                    safetyValue: 0,
                    // 创造多吃机会价值
                    opportunityValue: 0
                };
                
                // 检查是否可以立即吃子
                const targetPiece = pieces.find(p => p.type !== 'car' && p.x === move.x && p.y === move.y);
                if (targetPiece) {
                    evaluation.canCaptureNow = true;
                    evaluation.targetPiece = targetPiece;
                    
                    // 棋子价值评分（不同棋子价值不同）
                    evaluation.immediateValue = getPieceValue(targetPiece.type) * 100;
                    
                    // 如果可以连续吃子，计算最佳路径
                    const capturePathResult = evaluateCapturePath(move, 1, [...pieces]);
                    evaluation.capturePath = capturePathResult.path;
                    
                    // 连续吃子的价值（比单个吃子更高）
                    if (capturePathResult.maxCaptures > 1) {
                        evaluation.opportunityValue += (capturePathResult.maxCaptures - 1) * 50;
                    }
                }
                
                // 模拟车移动到新位置，计算位置优势
                const simulatedPieces = [...pieces];
                const carIndex = simulatedPieces.findIndex(p => p.type === 'car');
                const oldX = simulatedPieces[carIndex].x;
                const oldY = simulatedPieces[carIndex].y;
                simulatedPieces[carIndex].x = move.x;
                simulatedPieces[carIndex].y = move.y;
                
                // 评估此位置控制了多少条线路（横向和纵向）
                let controlledLines = 0;
                let threatenedPieces = 0;
                let minDistanceToTarget = Infinity;
                
                // 计算该位置能"看到"多少棋子（处于同一行或列且无阻挡）
                simulatedPieces.forEach(p => {
                    if (p.type !== 'car') {
                        // 检查车能否威胁到这个棋子
                        const onSameLine = (p.x === move.x || p.y === move.y);
                        const notBlocked = !isSimulatedPathBlocked(simulatedPieces, move.x, move.y, p.x, p.y);
                        
                        if (onSameLine && notBlocked) {
                            threatenedPieces++;
                            
                            // 增加控制线路数
                            if (p.x === move.x) controlledLines++;
                            if (p.y === move.y) controlledLines++;
                        }
                        
                        // 计算到最近棋子的距离
                        const distance = Math.abs(move.x - p.x) + Math.abs(move.y - p.y);
                        minDistanceToTarget = Math.min(minDistanceToTarget, distance);
                    }
                });
                
                // 还原车的位置
                simulatedPieces[carIndex].x = oldX;
                simulatedPieces[carIndex].y = oldY;
                
                // 计算位置价值（控制线路与威胁棋子）
                evaluation.positionValue = 20 * controlledLines + 30 * threatenedPieces;
                
                // 如果没有威胁棋子，则考虑靠近棋子
                if (threatenedPieces === 0 && minDistanceToTarget < Infinity) {
                    evaluation.positionValue += (10 - Math.min(minDistanceToTarget, 9)) * 5;
                }
                
                // 评估安全价值 - 远离危险棋子
                const dangerousPieces = pieces.filter(p => 
                    p.type !== 'car' && 
                    (p.type === 'rook' || p.type === 'cannon' || p.type === 'knight')
                );
                
                // 计算从该位置逃离危险棋子的价值
                dangerousPieces.forEach(p => {
                    // 计算当前与该危险棋子的距离
                    const currentDistance = Math.abs(oldX - p.x) + Math.abs(oldY - p.y);
                    // 计算移动后与该危险棋子的距离
                    const newDistance = Math.abs(move.x - p.x) + Math.abs(move.y - p.y);
                    
                    // 如果距离变大，增加安全价值
                    if (newDistance > currentDistance) {
                        evaluation.safetyValue += 5 * (newDistance - currentDistance);
                    }
                });
                
                // 计算总评分 - 立即吃子最重要，其次是位置价值和创造机会
                evaluation.score = 
                    evaluation.immediateValue + 
                    evaluation.opportunityValue + 
                    evaluation.positionValue + 
                    evaluation.safetyValue;
                
                return evaluation;
            });
            
            // 2. 根据评分排序
            evaluatedMoves.sort((a, b) => b.score - a.score);
            
            // 3. 选择最优移动
            const bestEvaluation = evaluatedMoves[0];
            
            // 4. 显示决策结果
            if (bestEvaluation.canCaptureNow) {
                // 能立即吃子的情况
                const pathStr = bestEvaluation.capturePath.map(pos => `(${pos.x},${pos.y})`).join(' → ');
                const captureCount = bestEvaluation.capturePath.length;
                
                resultArea.innerHTML = `
                    <h3>车的最佳移动</h3>
                    <p>最佳移动位置: <span style="font-weight: bolder;font-size:18px">(${bestEvaluation.move.x}, ${bestEvaluation.move.y})</span></p>
                    <p>可以吃掉: ${getPieceSymbol(bestEvaluation.targetPiece.type)}</p>
                    <p>评分: ${bestEvaluation.score}</p>
                    <p>此移动优势:
                    <ul>
                        ${bestEvaluation.immediateValue > 0 ? `<li>立即吃掉棋子 (+${bestEvaluation.immediateValue})</li>` : ''}
                        ${bestEvaluation.opportunityValue > 0 ? `<li>可能连续吃子 (+${bestEvaluation.opportunityValue})</li>` : ''}
                        ${bestEvaluation.positionValue > 0 ? `<li>获得良好位置 (+${bestEvaluation.positionValue})</li>` : ''}
                        ${bestEvaluation.safetyValue > 0 ? `<li>提高安全性 (+${bestEvaluation.safetyValue})</li>` : ''}
                    </ul>
                    </p>
                    ${captureCount > 1 ? `<p>最佳吃子路径: ${pathStr}</p>` : ''}
                `;
                
                const statusText = `车的最佳移动: (${bestEvaluation.move.x}, ${bestEvaluation.move.y}) - 吃掉 ${getPieceSymbol(bestEvaluation.targetPiece.type)}`;
                gameStatus.textContent = captureCount > 1 ? 
                    `${statusText}，如果布局不变可连续吃子` : statusText;
            } else {
                // 无法立即吃子的情况
                resultArea.innerHTML = `
                    <h3>车的最佳移动</h3>
                    <p>最佳移动位置: (${bestEvaluation.move.x}, ${bestEvaluation.move.y})</p>
                    <p>评分: ${bestEvaluation.score}</p>
                    <p>此移动优势:
                    <ul>
                        ${bestEvaluation.positionValue > 0 ? `<li>获得良好位置 (+${bestEvaluation.positionValue})</li>` : ''}
                        ${bestEvaluation.safetyValue > 0 ? `<li>提高安全性 (+${bestEvaluation.safetyValue})</li>` : ''}
                    </ul>
                    </p>
                    <p>此位置可控制更多棋子，为未来吃子创造条件</p>
                `;
                
                gameStatus.textContent = `车的最佳移动: (${bestEvaluation.move.x}, ${bestEvaluation.move.y}) - 战略位置，可控制更多区域`;
            }
            
            // 高亮显示最佳移动位置
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('move-suggestion'));
            const cell = findCell(bestEvaluation.move.x, bestEvaluation.move.y);
            if (cell) {
                cell.classList.add('move-suggestion');
            }
        }
        
        // 获取棋子的价值
        function getPieceValue(type) {
            switch(type) {
                case 'king': return 10;    // 将/帅
                case 'rook': return 9;     // 对方的车
                case 'cannon': return 7;   // 炮
                case 'knight': return 6;   // 马
                case 'bishop': return 4;   // 象
                case 'advisor': return 4;  // 士
                case 'pawn': return 2;     // 卒/兵
                default: return 1;
            }
        }
        
        // 用于模拟的路径阻挡检查
        function isSimulatedPathBlocked(simulatedPieces, fromX, fromY, toX, toY) {
            // 水平移动
            if (fromY === toY) {
                const minX = Math.min(fromX, toX);
                const maxX = Math.max(fromX, toX);
                
                for (let x = minX + 1; x < maxX; x++) {
                    if (simulatedPieces.some(p => p.x === x && p.y === fromY)) {
                        return true;
                    }
                }
            }
            
            // 垂直移动
            if (fromX === toX) {
                const minY = Math.min(fromY, toY);
                const maxY = Math.max(fromY, toY);
                
                for (let y = minY + 1; y < maxY; y++) {
                    if (simulatedPieces.some(p => p.x === fromX && p.y === y)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 评估从起始位置开始连续吃子的最大路径（贪心算法）
        function evaluateCapturePath(startPos, captureCount, simulatedPieces) {
            // 移除目标位置的棋子
            const targetIndex = simulatedPieces.findIndex(p => p.x === startPos.x && p.y === startPos.y && p.type !== 'car');
            if (targetIndex === -1) {
                return { maxCaptures: captureCount - 1, path: [startPos] };
            }
            
            // 移除被吃的棋子
            const capturedPiece = simulatedPieces[targetIndex];
            simulatedPieces.splice(targetIndex, 1);
            
            // 找到车并移动到新位置
            const carIndex = simulatedPieces.findIndex(p => p.type === 'car');
            if (carIndex === -1) {
                return { maxCaptures: captureCount - 1, path: [startPos] };
            }
            
            const oldX = simulatedPieces[carIndex].x;
            const oldY = simulatedPieces[carIndex].y;
            simulatedPieces[carIndex].x = startPos.x;
            simulatedPieces[carIndex].y = startPos.y;
            
            // 从当前位置寻找可以继续吃的子
            const nextMoves = [];
            
            // 横向搜索
            for (let x = 1; x <= 8; x++) {
                if (x !== startPos.x && !isSimulatedPathBlocked(simulatedPieces, startPos.x, startPos.y, x, startPos.y)) {
                    if (simulatedPieces.some(p => p.type !== 'car' && p.x === x && p.y === startPos.y)) {
                        nextMoves.push({ x, y: startPos.y });
                    }
                }
            }
            
            // 纵向搜索
            for (let y = 1; y <= 9; y++) {
                if (y !== startPos.y && !isSimulatedPathBlocked(simulatedPieces, startPos.x, startPos.y, startPos.x, y)) {
                    if (simulatedPieces.some(p => p.type !== 'car' && p.x === startPos.x && p.y === y)) {
                        nextMoves.push({ x: startPos.x, y });
                    }
                }
            }
            
            if (nextMoves.length === 0) {
                // 无法继续吃子，返回当前结果
                return { maxCaptures: captureCount, path: [startPos] };
            }
            
            // 递归评估每条路径，并选择最优的
            let bestResult = { maxCaptures: captureCount, path: [startPos] };
            
            for (const nextMove of nextMoves) {
                // 创建新的模拟棋盘状态
                const newSimulatedPieces = [...simulatedPieces];
                const result = evaluateCapturePath(nextMove, captureCount + 1, newSimulatedPieces);
                
                if (result.maxCaptures > bestResult.maxCaptures) {
                    bestResult = result;
                    bestResult.path.unshift(startPos);
                }
            }
            
            // 还原车的位置（为后续可能的递归调用准备）
            simulatedPieces[carIndex].x = oldX;
            simulatedPieces[carIndex].y = oldY;
            
            return bestResult;
        }
        
        // 为移动设备设置触摸事件处理
        function setupMobileTouchHandlers() {
            // 只在移动设备上运行此代码
            if (!isMobileDevice) return;
            
            console.log("设置移动端触摸处理");
            
            // 更新游戏状态提示
            gameStatus.textContent = "移动设备模式：点击棋子选中，再点击目标位置移动";
            
            // 移除所有棋子的拖拽属性，强制使用点击模式
            document.querySelectorAll('.piece').forEach(piece => {
                piece.draggable = false;
            });
        }
        
        // 移动端：处理棋子点击
        function handleMobilePieceClick(piece) {
            if (isDeleteMode) return;
            
            // 如果有选中的棋子，并且是车，且点击了另一个棋子，应该尝试吃子
            if (selectedPiece && selectedPiece.type === 'car' && piece !== selectedPiece) {
                // 检查车是否可以移动到该棋子位置
                if (isValidCarMove(selectedPiece.x, selectedPiece.y, piece.x, piece.y)) {
                    // 触发选择单元格的逻辑，执行吃子
                    selectCell(piece.x, piece.y);
                    return;
                } else {
                    gameStatus.textContent = "无法吃掉该棋子！车只能直线移动且不能越过其他棋子";
                    return;
                }
            }
            
            // 常规的选择棋子逻辑
            console.log("移动端点击棋子:", piece);
            
            // 取消之前的选择，如果点击的是同一个棋子
            if (selectedPiece === piece) {
                selectedPiece = null;
                renderPieces();
                gameStatus.textContent = "已取消选择";
                return;
            }
            
            // 如果点击的是新棋子
            selectedPiece = piece;
            renderPieces();
            
            // 更新状态提示
            gameStatus.textContent = `已选中${getPieceSymbol(piece.type)}，请点击目标位置移动`;
            
            // 如果是车，显示可能的移动位置
            if (piece.type === 'car') {
                showPossibleMoves();
            }
        }
        
        // 添加新棋子
        document.getElementById('addPiece').addEventListener('click', () => {
            // 如果处于删除模式，先退出删除模式
            if (isDeleteMode) {
                toggleDeleteMode();
            }
            
            const type = document.getElementById('pieceType').value;
            const x = parseInt(document.getElementById('xCoord').value);
            const y = parseInt(document.getElementById('yCoord').value);
            
            // 验证输入
            if (isNaN(x) || isNaN(y) || x < 1 || x > 8 || y < 1 || y > 9) {
                alert('无效的坐标！');
                return;
            }
            
            // 检查该位置是否已有棋子
            if (pieces.some(p => p.x === x && p.y === y)) {
                alert('该位置已有棋子！');
                return;
            }
            
            // 添加棋子
            pieces.push({ type, x, y });
            renderPieces();
            
            gameStatus.textContent = `添加了 ${getPieceSymbol(type)} 在坐标 (${x}, ${y})`;
            
            // 重新计算最佳移动
            setTimeout(calculateBestMoveForCar, 500);
        });
        
        // 删除棋子模式切换
        document.getElementById('toggleDeleteMode').addEventListener('click', toggleDeleteMode);
        
        // 计算最佳移动
        document.getElementById('calculateMove').addEventListener('click', calculateBestMoveForCar);
        
        // 重置棋盘
        document.getElementById('resetBoard').addEventListener('click', () => {
            // 如果处于删除模式，先退出删除模式
            if (isDeleteMode) {
                toggleDeleteMode();
            }
            initBoard();
        });
        
        // 保存棋局到本地存储
        function saveGameToLocalStorage(name) {
            if (!name) {
                alert('请输入存档名称！');
                return;
            }
            
            // 创建游戏存档对象
            const gameState = {
                pieces: pieces,
                carPosition: carPosition,
                timestamp: new Date().toISOString(),
                name: name
            };
            
            // 获取现有存档列表
            let savedGames = JSON.parse(localStorage.getItem('chessGames') || '[]');
            
            // 检查是否有同名存档
            const existingIndex = savedGames.findIndex(game => game.name === name);
            if (existingIndex >= 0) {
                if (confirm(`已存在名为"${name}"的存档，是否覆盖？`)) {
                    savedGames[existingIndex] = gameState;
                } else {
                    return;
                }
            } else {
                // 添加新存档
                savedGames.push(gameState);
            }
            
            // 保存到本地存储
            localStorage.setItem('chessGames', JSON.stringify(savedGames));
            
            gameStatus.textContent = `已成功保存棋局 "${name}"`;
            
            // 更新存档列表（如果已显示）
            if (document.getElementById('archiveList').style.display !== 'none') {
                loadGameList();
            }
        }
        
        // 加载棋局列表
        function loadGameList() {
            const archiveList = document.getElementById('archiveList');
            
            // 显示存档列表区域
            archiveList.style.display = 'block';
            
            // 获取所有存档
            const savedGames = JSON.parse(localStorage.getItem('chessGames') || '[]');
            
            if (savedGames.length === 0) {
                archiveList.innerHTML = '<p>暂无存档</p>';
                return;
            }
            
            // 生成存档列表HTML
            let html = '';
            savedGames.forEach((game, index) => {
                const date = new Date(game.timestamp).toLocaleString();
                html += `
                    <div class="archive-item">
                        <div class="archive-name">${game.name} (${date})</div>
                        <button class="btn btn-sm" onclick="loadGame('${game.name}')">加载</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteGame('${game.name}')">删除</button>
                    </div>
                `;
            });
            
            archiveList.innerHTML = html;
        }
        
        // 加载指定存档
        function loadGame(name) {
            // 获取所有存档
            const savedGames = JSON.parse(localStorage.getItem('chessGames') || '[]');
            
            // 查找指定存档
            const gameState = savedGames.find(game => game.name === name);
            
            if (!gameState) {
                alert(`找不到名为"${name}"的存档！`);
                return;
            }
            
            // 确认是否加载
            if (!confirm(`确定要加载"${name}"？当前棋盘将被覆盖。`)) {
                return;
            }
            
            // 恢复棋盘状态
            pieces = gameState.pieces;
            carPosition = gameState.carPosition;
            
            // 刷新棋盘
            renderPieces();
            
            gameStatus.textContent = `已加载棋局 "${name}"`;
            
            // 计算最佳移动
            setTimeout(calculateBestMoveForCar, 500);
        }
        
        // 删除存档
        function deleteGame(name) {
            if (!confirm(`确定要删除"${name}"存档吗？此操作不可撤销。`)) {
                return;
            }
            
            // 获取所有存档
            let savedGames = JSON.parse(localStorage.getItem('chessGames') || '[]');
            
            // 过滤掉要删除的存档
            savedGames = savedGames.filter(game => game.name !== name);
            
            // 保存回本地存储
            localStorage.setItem('chessGames', JSON.stringify(savedGames));
            
            // 更新界面
            loadGameList();
            gameStatus.textContent = `已删除存档 "${name}"`;
        }
        
        // 导出存档为文件
        function exportGame(name) {
            // 获取所有存档
            const savedGames = JSON.parse(localStorage.getItem('chessGames') || '[]');
            
            // 查找指定存档
            const gameState = savedGames.find(game => game.name === name);
            
            if (!gameState) {
                alert(`找不到名为"${name}"的存档！`);
                return;
            }
            
            // 将存档转换为JSON字符串
            const gameStateJson = JSON.stringify(gameState, null, 2);
            
            // 创建下载链接
            const blob = new Blob([gameStateJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // 创建下载元素并点击
            const a = document.createElement('a');
            a.href = url;
            a.download = `${name}_棋局存档.json`;
            a.click();
            
            // 释放URL
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }
        
        // 添加按钮事件监听器
        document.getElementById('saveGame').addEventListener('click', () => {
            const name = document.getElementById('archiveName').value.trim();
            saveGameToLocalStorage(name);
        });
        
        document.getElementById('loadGameList').addEventListener('click', loadGameList);
        
        // 添加全局函数用于HTML中直接调用
        window.loadGame = loadGame;
        window.deleteGame = deleteGame;
        window.exportGame = exportGame;
        
        // 初始化棋盘
        initBoard();
        
        // 检测设备类型并显示相应提示
        if (isMobileDevice) {
            document.getElementById('mobileControls').style.display = 'block';
            console.log("检测到移动设备，启用触摸控制");
        }
    </script>
</body>
</html>
